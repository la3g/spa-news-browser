<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive D3 Word List with Gemini</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script src="config.js"></script>
    
    <style>
        body {
            font-family: 'Arial', sans-serif;
            background: white;
            margin: 0;
            padding: 0;
            height: 100vh;
            display: flex;
            overflow: hidden;
        }
        
        .left-pane {
            width: 50%;
            height: 100vh;
            display: flex;
            flex-direction: column;
            box-sizing: border-box;
        }
        
        .controls-container {
            padding: 20px 40px 20px 40px;
            flex-shrink: 0;
        }
        
        .word-scroll-container {
            flex: 1;
            overflow-y: auto;
            padding: 0 40px 40px 40px;
            min-height: 0;
        }
        
        .divider {
            width: 4px;
            background: #e0e0e0;
            cursor: ew-resize;
            position: relative;
            transition: background-color 0.2s ease;
        }
        
        .divider:hover {
            background: #4a90e2;
        }
        
        .divider::after {
            content: '';
            position: absolute;
            left: -4px;
            top: 0;
            width: 12px;
            height: 100%;
        }
        
        .right-pane {
            flex: 1;
            height: 100vh;
            padding: 40px;
            background: #f9f9f9;
            overflow-y: auto;
            box-sizing: border-box;
        }
        
        .title-list-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid #e0e0e0;
        }
        
        .title-list-header h2 {
            margin: 0;
            color: #2c3e50;
            font-size: 24px;
        }
        
        .title-list-controls {
            display: flex;
            gap: 10px;
        }
        
        .control-button {
            padding: 8px 16px;
            border: 1px solid #ddd;
            background: white;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s ease;
        }
        
        .control-button:hover {
            background: #f0f0f0;
            border-color: #4a90e2;
        }
        
        .control-button.active {
            background: #4a90e2;
            color: white;
            border-color: #4a90e2;
        }
        
        .title-group {
            margin-bottom: 25px;
        }
        
        .title-group-header {
            background: #e8f0fe;
            padding: 10px 15px;
            border-radius: 4px;
            margin-bottom: 10px;
            font-weight: 600;
            color: #1a73e8;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .title-group-count {
            font-size: 12px;
            background: #1a73e8;
            color: white;
            padding: 2px 8px;
            border-radius: 12px;
        }
        
        .title-item {
            background: white;
            border: 1px solid #e0e0e0;
            border-radius: 4px;
            padding: 15px;
            margin-bottom: 10px;
            transition: all 0.2s ease;
            cursor: pointer;
        }
        
        .title-item:hover {
            border-color: #4a90e2;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            transform: translateY(-1px);
        }
        
        .title-item-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 8px;
        }
        
        .title-text {
            font-size: 16px;
            font-weight: 500;
            color: #2c3e50;
            flex: 1;
            margin-right: 10px;
        }
        
        .title-date {
            font-size: 12px;
            color: #7f8c8d;
            white-space: nowrap;
        }
        
        .title-meta {
            display: flex;
            gap: 15px;
            font-size: 13px;
            color: #95a5a6;
        }
        
        .title-domain {
            color: #3498db;
        }
        
        .title-score {
            color: #e74c3c;
        }
        
        .dropdown-select {
            width: 100%;
            padding: 10px 12px;
            border: 2px solid #e0e0e0;
            border-radius: 6px;
            font-size: 14px;
            color: #333;
            background: white;
            cursor: pointer;
            transition: border-color 0.3s ease;
        }
        
        .dropdown-select:hover {
            border-color: #4a90e2;
        }
        
        .dropdown-select:focus {
            outline: none;
            border-color: #4a90e2;
            box-shadow: 0 0 0 3px rgba(74, 144, 226, 0.1);
        }
        
.word {
    cursor: pointer;
    transition: all 0.8s cubic-bezier(0.25, 0.46, 0.45, 0.94);
    display: block;
    margin: 2px 0;
    padding: 4px 6px;
    font-weight: 600;
    color: #2c3e50;
    position: relative;
    white-space: nowrap;
    transform-origin: left center;
}
        

.title-group-header {
    background: #e8f0fe;
    padding: 10px 15px;
    border-radius: 4px;
    margin-bottom: 10px;
    font-weight: 600;
    color: #1a73e8;
    display: flex;
    justify-content: space-between;
    align-items: center;
    cursor: pointer;
    user-select: none;
}

.title-group-header:hover {
    background: #d2e3fc;
}

.title-group.collapsed .title-item {
    display: none;
}

.title-group-header::before {
    content: '‚ñº';
    margin-right: 8px;
    font-size: 12px;
    transition: transform 0.2s ease;
}

.title-group.collapsed .title-group-header::before {
    transform: rotate(-90deg);
}
        
        .font-size-indicator {
            color: #bbb;
            font-weight: normal;
            opacity: 0;
            transition: opacity 0.3s ease;
        }
        
        .loading {
            text-align: center;
            padding: 40px;
            color: #666;
        }
        
        .error {
            text-align: center;
            padding: 40px;
            color: #e74c3c;
        }
        
        /* External site headline styling - for browser extension/User CSS */
        h1.b-headline,
        h1.b-headline[data-cursor-element-id="cursor-el-404"] {
            color: green !important;
        }
    </style>
</head>
<body>
    <div class="left-pane" id="leftPane">
        <div class="controls-container">
            <div style="display: flex; gap: 20px; align-items: flex-start; margin: 0; padding: 0;">
                <div style="flex: 2;">
                    <div style="text-align: center; font-size: 14px; color: #333; margin: 0;">Range: <span id="rangeValues">1 - 15</span></div>
                    <div style="position: relative; height: 20px; margin: 0;">
                        <div style="position: absolute; top: 8px; left: 0; right: 0; height: 4px; background: #e0e0e0; border-radius: 2px;"></div>
                        <div style="position: absolute; top: 8px; height: 4px; background: #4a90e2; border-radius: 2px;" id="sliderRange"></div>
                        <div style="position: absolute; top: 0; width: 20px; height: 20px; background: #4a90e2; border: 2px solid white; border-radius: 50%; cursor: grab; box-shadow: 0 2px 6px rgba(0,0,0,0.2); transition: transform 0.2s ease;" id="leftThumb"></div>
                        <div style="position: absolute; top: 0; width: 20px; height: 20px; background: #4a90e2; border: 2px solid white; border-radius: 50%; cursor: grab; box-shadow: 0 2px 6px rgba(0,0,0,0.2); transition: transform 0.2s ease;" id="rightThumb"></div>
                    </div>
                    <div style="display: flex; justify-content: space-between; font-size: 12px; color: #666; margin: 0; padding: 0;">
              <span>May 1</span>
    <span id="sliderMidLabel">May 15</span>
    <span id="sliderMaxLabel">May 30</span>
                    </div>
                </div>
                <div style="flex: 1; margin-top: 25px;">
                    <select id="categorySelect" class="dropdown-select">
                        <option value="">Todas las categor√≠as</option>
                    </select>
                </div>
            </div>
        </div>
        
        <div class="word-scroll-container">
<div id="wordContainer" style="margin: 0; padding: 0; line-height: 0.8;">
                <div class="loading">Loading words...</div>
            </div>
        </div>
    </div>
    <div class="divider" id="divider"></div>
    <div class="right-pane" id="rightPane">
        <div class="loading">Loading articles...</div>
    </div>

    <script type="module">
        // Import the official ES6 module from Google's recommended CDN.
        import { GoogleGenerativeAI } from 'https://esm.run/@google/generative-ai';

        // ========================================
        // Title List Component
        // ========================================
        
        // ========================================
        // Gemini Model Configuration
        // ========================================
        // FUTURE-PROOFING: Model fallback list
        // 
        // This list is tried in order when making API calls. If a model is deprecated,
        // it will automatically try the next one. To update:
        // 1. Check Google's current models: https://ai.google.dev/gemini-api/docs/models
        // 2. Add newer models to the TOP of this list (most preferred first)
        // 3. Keep older models as fallbacks
        // 4. The working model will be logged to console on first successful call
        //
        // Last updated: 2025-01-XX (when gemini-2.0-flash-exp was confirmed working)
        const GEMINI_MODEL_FALLBACK_LIST = [
            "gemini-2.0-flash-exp",  // Currently working (2025)
            "gemini-2.0-flash",      // Stable version when available
            "gemini-1.5-pro",        // Fallback option
            "gemini-1.5-flash",      // Fallback option
            "gemini-pro"             // Legacy fallback
        ];
        
        class TitleListComponent {
           constructor(containerId, config = {}) {
                this.container = document.getElementById(containerId);
                this.config = {
                    onTitleClick: config.onTitleClick || null,
                    dateFormat: config.dateFormat || 'relative',
                    ...config
                };
                this.titles = [];
                this.entity = null;
                this.sortOrder = 'desc';
                
                // --- This is the new state management ---
                this.groupingMode = 'none'; // Can be 'none', 'domain', or 'event'

                // --- This is the Gemini initialization logic that was missing ---
                this.genAI = null;
                this.model = null;
                this.modelName = null;
                this.workingModel = null; // Cache the working model after first success
                
                if (config.apiKey) {
                    this.genAI = new GoogleGenerativeAI(config.apiKey);
                    // Initialize with first model in fallback list
                    // Will be tested and potentially switched on first API call
                    this.modelName = GEMINI_MODEL_FALLBACK_LIST[0];
                    this.model = this.genAI.getGenerativeModel({ model: this.modelName });
                } else {
                    console.error("Gemini API Key is missing!");
                }
            }

     setTitles(titles, entity = null) {
                this.titles = titles;
                this.entity = entity;
                this.render();
            }

render() {
    const header = this._createHeader();
    const content = document.createElement('div');
    content.className = 'title-list-content';

    // --- CHANGE: Use 'groupingMode' to decide which view to render ---
    // Note: The 'event' view is handled separately and does not use this render() function.
    const view = this.groupingMode === 'domain' ? this._renderGroupedView() : this._renderFlatView();
    content.appendChild(view);

    this.container.innerHTML = '';
    this.container.appendChild(header);
    this.container.appendChild(content);

    this._attachEventHandlers();
}

_createHeader() {
    const header = document.createElement('div');
    header.className = 'title-list-header';

    // Prepare dynamic text and classes
    let headerText = "Related Articles";
    if (this.entity) {
        headerText = 'Related Articles for "' + this.entity + '"';
    }
    const fullTitle = headerText + ' (' + this.titles.length + ')';

    const eventButtonClass = 'control-button ' + (this.groupingMode === 'event' ? 'active' : '');
    const domainButtonClass = 'control-button ' + (this.groupingMode === 'domain' ? 'active' : '');
    const sortButtonText = 'üìÖ Date ' + (this.sortOrder === 'asc' ? '‚Üë' : '‚Üì');

    // Build the HTML using the new text and classes
    header.innerHTML =
        '<h2>' + fullTitle + '</h2>' +
        '<div class="title-list-controls">' +
            '<button class="' + eventButtonClass + '" id="groupByEventsBtn">‚ú® Group By Events</button>' +
            // --- CHANGE: Updated label and class logic ---
            '<button class="' + domainButtonClass + '" id="groupToggle">üìÅ Group by Domain</button>' +
            '<button class="control-button" id="sortToggle">' +
                sortButtonText +
            '</button>' +
        '</div>';

    return header;
}

            _renderGroupedView() {
                const container = document.createElement('div');
                container.className = 'grouped';
                
                const grouped = this._groupByDomain(this.titles);
                const sortedGroups = Object.entries(grouped).sort((a, b) => b[1].length - a[1].length);
                
                sortedGroups.forEach(([domain, items]) => {
                    const group = document.createElement('div');
                    group.className = 'title-group';
                    group.dataset.domain = domain;
                    
                    const groupHeader = document.createElement('div');
                    groupHeader.className = 'title-group-header';
                    groupHeader.innerHTML = `
                        <span>${domain}</span>
                        <span class="title-group-count">${items.length}</span>
                    `;
                    
                    groupHeader.addEventListener('click', () => {
                        group.classList.toggle('collapsed');
                    });
                    
                    group.appendChild(groupHeader);
                    
                    const sortedItems = this._sortByDate(items);
                    sortedItems.forEach(item => {
                        group.appendChild(this._createTitleElement(item));
                    });
                    
                    container.appendChild(group);
                });
                
                return container;
            }

            _renderFlatView() {
                const container = document.createElement('div');
                container.className = 'flat';
                
                const sortedTitles = this._sortByDate([...this.titles]);
                sortedTitles.forEach(title => {
                    container.appendChild(this._createTitleElement(title));
                });
                
                return container;
            }

            _createTitleElement(item) {
                const element = document.createElement('div');
                element.className = 'title-item';
                element.dataset.id = item.id;
                
                const dateStr = this._formatDate(item.publishDate);
                
                element.innerHTML = `
                    <div class="title-item-header">
                        <div class="title-text">${item.title}</div>
                        <div class="title-date">${dateStr}</div>
                    </div>
                    <div class="title-meta">
                        <span class="title-domain">üåê ${item.domain}</span>
                    </div>
                `;
                
                return element;
            }

            _groupByDomain(titles) {
                return titles.reduce((groups, title) => {
                    const domain = title.domain;
                    if (!groups[domain]) {
                        groups[domain] = [];
                    }
                    groups[domain].push(title);
                    return groups;
                }, {});
            }

            _sortByDate(titles) {
                return titles.sort((a, b) => {
                    const dateA = new Date(a.publishDate);
                    const dateB = new Date(b.publishDate);
                    return this.sortOrder === 'asc' ? dateA - dateB : dateB - dateA;
                });
            }

            _formatDate(dateStr) {
                const date = new Date(dateStr);
                const day = String(date.getDate()).padStart(2, '0');
                const month = String(date.getMonth() + 1).padStart(2, '0');
                const year = String(date.getFullYear()).slice(-2);
                
                return `${day}/${month}/${year}`;
            }

            _attachEventHandlers() {
    // --- CHANGE: Update click handler logic for new state management ---
    this.container.querySelector('#groupToggle')?.addEventListener('click', () => {
        // Toggle between 'domain' and 'none' (flat) mode
        this.groupingMode = (this.groupingMode === 'domain') ? 'none' : 'domain';
        this.render();
    });

    this.container.querySelector('#groupByEventsBtn')?.addEventListener('click', () => {
        // Set mode to 'event' and call the handler
        this.groupingMode = 'event';
        this._handleGroupByEventsClick();
    });

    // --- This part stays the same ---
    this.container.querySelector('#sortToggle')?.addEventListener('click', () => {
        this.sortOrder = this.sortOrder === 'asc' ? 'desc' : 'asc';
        // Need to re-render to see the sorted list
        if (this.groupingMode === 'none' || this.groupingMode === 'domain') {
            this.render();
        }
        // Note: Sorting does not re-trigger an event grouping.
    });

    const titleItems = this.container.querySelectorAll('.title-item');
    titleItems.forEach(item => {
        item.addEventListener('click', () => {
            const titleId = item.dataset.id;
            const title = this.titles.find(t => t.id === titleId);
            if (this.config.onTitleClick && title) {
                this.config.onTitleClick(title);
            }
        });
    });
}

            _handleGroupByEventsClick = async () => {
                // The click handler has already set this.groupingMode = 'event'

                // --- Step 1: Re-render the entire component in a loading state ---
                this.container.innerHTML = ''; // Clear the entire right pane
                
                // Add the new header, which will now have the 'active' class on the correct button
                this.container.appendChild(this._createHeader()); 

                // Create and add the content area with a loading message
                const contentArea = document.createElement('div');
                contentArea.className = 'title-list-content';
                contentArea.innerHTML = '<div class="loading">Grouping events with Gemini...</div>';
                this.container.appendChild(contentArea);
                
                // Re-attach event handlers to the new buttons in the header
                this._attachEventHandlers();

                // --- Step 2: Call the API ---
                try {
                    const events = await this._callGeminiService(this.titles);
                    
                    // --- Step 3: Render the final event view into the content area ---
                    this._renderEventsView(events, contentArea); 

                } catch (error) {
                    console.error("Error grouping events:", error);
                    // Update the content area with an error message, leaving the header intact
                    contentArea.innerHTML = `<div class="error">Failed to group events with Gemini.</div>`;
                }
            }

                        showLoading() {
                this.container.innerHTML = '<div class="loading">Loading articles...</div>';
            }

            showError(message) {
                this.container.innerHTML = `<div class="error">${message}</div>`;
            }

 _renderEventsView(events, container) {
                container.innerHTML = '';
                container.className = 'title-list-content events';

                if (!events || events.length === 0) {
                    container.innerHTML = '<div class="loading">No events were identified.</div>';
                    return;
                }

                // --- NEW: Sort events by the number of articles in descending order ---
                const sortedEvents = events.sort((a, b) => {
                    const lengthA = a.article_ids ? a.article_ids.length : 0;
                    const lengthB = b.article_ids ? b.article_ids.length : 0;
                    return lengthB - lengthA;
                });

                // Use the new 'sortedEvents' array to render the groups
                sortedEvents.forEach(event => {
                    if (!event.article_ids || event.article_ids.length === 0) return;

                    const group = document.createElement('div');
                    group.className = 'title-group collapsed';

                    const groupHeader = document.createElement('div');
                    groupHeader.className = 'title-group-header';
                    groupHeader.innerHTML = `
                        <span>‚ú® ${event.eventName}</span>
                        <span class="title-group-count">${event.article_ids.length}</span>
                    `;
                    groupHeader.addEventListener('click', () => group.classList.toggle('collapsed'));
                    
                    group.appendChild(groupHeader);
                    
                    event.article_ids.forEach(articleId => {
                        const originalArticle = this.titles.find(t => t.id === articleId);
                        if (originalArticle) {
                           group.appendChild(this._createTitleElement(originalArticle));
                        }
                    });
                    
                    container.appendChild(group);
                });
            }

        
    
    
        async _callGeminiService(articles) {
                console.log("Calling Gemini API with optimized prompt...");

                const articlesForApi = articles.map(article => ({
                    id: article.id,
                    title: article.title
                }));
    
                const prompt = `You are an expert event analysis AI. Your task is to organize the following list of news articles into distinct real-world events in Spanish.

Rules:
1.  Analyze the provided articles, which have an "id" and a "title".
2.  Group articles that refer to the same underlying event.
3.  Return your response as a valid JSON array of objects.
4.  Each object must have two keys: "eventName" (a concise string) and "article_ids" (an array of the original article 'id' strings that belong to that event).
5.  Do not include any text, markdown, or explanations outside of the final JSON array.

Here is the list of articles:
${JSON.stringify(articlesForApi, null, 2)}`;
                
                // FUTURE-PROOFING: Use cached working model if available, otherwise try fallback list
                // This avoids trying multiple models on every call once we know what works
                const modelsToTry = this.workingModel 
                    ? [this.workingModel]  // Use cached working model
                    : GEMINI_MODEL_FALLBACK_LIST;  // Try all fallbacks on first call
                
                let lastError = null;
                
                for (const modelName of modelsToTry) {
                    try {
                        // Update model if different from current
                        if (this.modelName !== modelName) {
                            console.log(`üîÑ Trying model: ${modelName}`);
                            this.modelName = modelName;
                            this.model = this.genAI.getGenerativeModel({ model: modelName });
                        }
                        
                        // --- Try to count tokens (may not be supported for all models) ---
                        try {
                            const tokenCountResponse = await this.model.countTokens(prompt);
                            console.log("‚úÖ [ESTIMATED INPUT TOKENS]:", tokenCountResponse.totalTokens);
                        } catch (tokenError) {
                            // countTokens not supported - continue anyway
                            console.warn("‚ö†Ô∏è Token counting not available for this model");
                        }

                        const result = await this.model.generateContent(prompt);
                        
                        // --- Log the actual usage from the response metadata ---
                        if (result.response?.usageMetadata) {
                            console.log("‚úÖ [ACTUAL USAGE METADATA]:", result.response.usageMetadata);
                        }
                        
                        const responseText = result.response.text();
                        
                        // Robust JSON parsing logic
                        const jsonStart = responseText.indexOf('[');
                        const jsonEnd = responseText.lastIndexOf(']') + 1;
                        if (jsonStart === -1 || jsonEnd === 0) {
                            throw new Error("No valid JSON array found in the response.");
                        }
                        const jsonString = responseText.substring(jsonStart, jsonEnd);
                        const jsonResponse = JSON.parse(jsonString);
                        
                        // Cache the working model for future calls
                        if (!this.workingModel) {
                            this.workingModel = modelName;
                            console.log(`‚úÖ Successfully used model: ${modelName} (cached for future calls)`);
                        }
                        
                        return jsonResponse;
                        
                    } catch(error) {
                        // If using cached model and it fails, clear cache and retry with fallback list
                        if (this.workingModel && this.workingModel === modelName) {
                            console.warn(`‚ö†Ô∏è Cached model ${modelName} failed, clearing cache and retrying...`);
                            this.workingModel = null;
                            // Retry with full fallback list
                            return this._callGeminiService(articles);
                        }
                        
                        console.warn(`‚ùå Model ${modelName} failed:`, error.message);
                        lastError = error;
                        // Continue to next model
                        continue;
                    }
                }
                
                // If all models failed, throw the last error
                console.error("‚ùå All model attempts failed. Check GEMINI_MODEL_FALLBACK_LIST and update with current models from: https://ai.google.dev/gemini-api/docs/models");
                console.error("Last error:", lastError);
                throw lastError || new Error("Failed to call Gemini API with any available model");
            }

        }

        // ========================================
        // Data Service Module
        // ========================================
        
        class DataService {
    constructor(supabaseUrl, supabaseKey) {
        this.supabase = window.supabase.createClient(supabaseUrl, supabaseKey);
    }

    async fetchWords(filters = {}) {
    try {
        let query = this.supabase
            .from('entities')
            .select('entity, category, frequency')
            .order('frequency', { ascending: false });

        if (filters.category) {
            query = query.like('category', `${filters.category}%`);
        }

        const { data, error } = await query;
        
        if (error) throw error;
        
        return data.map(item => ({
            text: item.entity,
            category: item.category,
            frequency: item.frequency
        }));
    } catch (error) {
        console.error('Error fetching words:', error);
        throw error;
    }
}

async fetchCategories() {
    return [
        'Evento', 'Equipo', 'Lugar', 'Organizaci√≥n', 
        'Persona', 'Medio', 'Marca', 'Grupo', 
        'Fen√≥meno', 'Concepto', 'Ciudad'
    ];
}

async fetchTitlesForWord(word, filters = {}) {
    try {
        const { data, error } = await this.supabase
            .from('articles')
            .select('title, domain, published_date')
            .ilike('title', `%${word}%`)
            .order('published_date', { ascending: false });
        
        if (error) throw error;
        
        return data.map((item, index) => ({
            id: `article_${item.title.substring(0,10)}_${index}`,
            title: item.title,
            domain: item.domain,
            publishDate: item.published_date || new Date().toISOString(),
            relevanceScore: 0,
            mentions: 0,
            url: `http://${item.domain}`,
            excerpt: ''
        }));
    } catch (error) {
        console.error('Error fetching titles:', error);
        return [];
    }
}

    async getTitleDetails(titleId) {
        return new Promise((resolve) => {
            setTimeout(() => {
                const title = this.mockData.titles.find(t => t.id === titleId);
                if (title) {
                    resolve({
                        ...title,
                        fullContent: 'Full article content would be loaded here...',
                        relatedLinks: [
                            { text: 'Related Article 1', url: '#' },
                            { text: 'Related Article 2', url: '#' }
                        ]
                    });
                } else {
                    resolve(null);
                }
            }, 200);
        });
    }

    mockData = {
        titles: []
    };
}

        // ========================================
        // Word List Component
        // ========================================
        class WordListComponent {
            constructor(containerId, config = {}) {
                this.container = d3.select(`#${containerId}`);
                this.config = {
                    minFontSize: config.minFontSize || 10,
                    maxFontSize: config.maxFontSize || 52,
                    hoverFontSize: config.hoverFontSize || 44,
                    fontScaleType: config.fontScaleType || 'log',
                    ...config
                };
                this.words = [];
                this.wordElements = null;
                this.onWordClick = config.onWordClick || null;
            }

            setWords(words) {
                this.words = words;
                this.render();
            }

            render() {
                this.container.html('');

                if (this.words.length === 0) {
                    this.container.html('<div class="loading">No words to display</div>');
                    return;
                }
const minFreq = Math.min(...this.words.map(w => w.frequency));
const maxFreq = Math.max(...this.words.map(w => w.frequency));

const fontScale = d3.scaleLog()
    .domain([minFreq || 1, maxFreq || 100])
    .range([this.config.minFontSize, this.config.maxFontSize])
    .base(10);

                this.wordElements = this.container
                    .selectAll('.word')
                    .data(this.words)
                    .enter()
                    .append('span')
                    .attr('class', 'word')
                    .attr('data-category', d => d.category)
                    .attr('data-index', (d, i) => i + 1)
                    .style('font-size', (d, i) => fontScale(d.frequency) + 'px')
                    .each(function(d, i) {
                        const element = d3.select(this);
                        const originalFontSize = Math.round(fontScale(i + 1));
                        
                        element.append('span')
                            .attr('class', 'word-text')
                            .text(d.text);
                        
                        element.append('span')
                    .attr('class', 'font-size-indicator')
                    .text(` (${d.frequency})`);
                    });

                this._attachEventHandlers();
                this._animateEntrance();
            }

            _attachEventHandlers() {
                const self = this;
                
                this.wordElements
                    .on('mouseenter', function(event, d) {
                        const currentElement = d3.select(this);
                        
                        currentElement
                            .transition()
                            .duration(700)
                            .ease(d3.easePolyOut.exponent(2))
                            .style('font-size', self.config.hoverFontSize + 'px')
                            .style('color', '#7f8c8d');
                        
                        currentElement.select('.font-size-indicator')
                            .transition()
                            .duration(300)
                            .style('opacity', 1);
                    })
 .on('mouseleave', function(event, d) {
    const currentElement = d3.select(this);
    
    const minFreq = Math.min(...self.words.map(w => w.frequency));
    const maxFreq = Math.max(...self.words.map(w => w.frequency));
    
const fontScale = d3.scaleLog()
    .domain([minFreq || 1, maxFreq || 100])
    .range([self.config.minFontSize, self.config.maxFontSize])
    .base(10);
    
    const originalSize = fontScale(d.frequency) + 'px';
    
    currentElement
        .transition()
        .duration(600)
        .ease(d3.easePolyOut.exponent(3))
        .style('font-size', originalSize)
        .style('color', '#2c3e50');
    
    currentElement.select('.font-size-indicator')
        .transition()
        .duration(300)
        .style('opacity', 0);
})


                    .on('click', function(event, d) {
                        if (self.onWordClick) {
                            self.onWordClick(d, event);
                        }
                    });
            }

_animateEntrance() {
    this.wordElements.style('color', '#2c3e50');

}

            filter(filterFn) {
                if (this.wordElements) {
                    this.wordElements.style('display', (d, i) => {
                        return filterFn(d, i) ? 'block' : 'none';
                    });
                }
            }

            showError(message) {
                this.container.html(`<div class="error">${message}</div>`);
            }

            showLoading() {
                this.container.html('<div class="loading">Loading words...</div>');
            }
        }

        // ========================================
        // Slider Component
        // ========================================
        class RangeSliderComponent {
            constructor(config = {}) {
                this.config = {
                    min: config.min || 1,
                    max: config.max || 30,
                    leftValue: config.leftValue || 1,
                    rightValue: config.rightValue || 15,
                    onChange: config.onChange || null,
                    ...config
                };
                
                this.elements = {
                    wrapper: document.querySelector('.controls-container > div > div:first-child > div:nth-child(2)'),
                    range: document.getElementById('sliderRange'),
                    leftThumb: document.getElementById('leftThumb'),
                    rightThumb: document.getElementById('rightThumb'),
                    rangeValues: document.getElementById('rangeValues'),
                    maxLabel: document.getElementById('sliderMaxLabel'),
                    midLabel: document.getElementById('sliderMidLabel')
                };
                
                this.state = {
                    isDragging: false,
                    activeThumb: null
                };
                
                this._init();
            }

            _init() {
                this._attachEventHandlers();
                this.updateSlider();
            }

            updateConfig(newConfig) {
                Object.assign(this.config, newConfig);
                this.elements.maxLabel.textContent = this.config.max;
                this.elements.midLabel.textContent = Math.floor(this.config.max / 2);
                this.updateSlider();
            }

updateSlider() {
    const leftPercent = ((this.config.leftValue - this.config.min) / (this.config.max - this.config.min)) * 100;
    const rightPercent = ((this.config.rightValue - this.config.min) / (this.config.max - this.config.min)) * 100;
    
    this.elements.leftThumb.style.left = `calc(${leftPercent}% - 10px)`;
    this.elements.rightThumb.style.left = `calc(${rightPercent}% - 10px)`;
    
    this.elements.range.style.left = `${leftPercent}%`;
    this.elements.range.style.width = `${rightPercent - leftPercent}%`;
    
    this.elements.rangeValues.textContent = `May ${this.config.leftValue} - May ${this.config.rightValue}`;
    
    if (this.config.onChange) {
        this.config.onChange(this.config.leftValue, this.config.rightValue);
    }
}

            _getValueFromPosition(x) {
                const rect = this.elements.wrapper.getBoundingClientRect();
                const percent = Math.max(0, Math.min(1, (x - rect.left) / rect.width));
                return Math.round(this.config.min + percent * (this.config.max - this.config.min));
            }

            _attachEventHandlers() {
                const handleMouseDown = (thumb, e) => {
                    e.preventDefault();
                    this.state.isDragging = true;
                    this.state.activeThumb = thumb;
                    document.addEventListener('mousemove', handleMouseMove);
                    document.addEventListener('mouseup', handleMouseUp);
                };

                const handleMouseMove = (e) => {
                    if (!this.state.isDragging) return;
                    
                    const newValue = this._getValueFromPosition(e.clientX);
                    
                    if (this.state.activeThumb === this.elements.leftThumb) {
                        this.config.leftValue = Math.min(newValue, this.config.rightValue - 1);
                    } else {
                        this.config.rightValue = Math.max(newValue, this.config.leftValue + 1);
                    }
                    
                    this.updateSlider();
                };

                const handleMouseUp = () => {
                    this.state.isDragging = false;
                    this.state.activeThumb = null;
                    document.removeEventListener('mousemove', handleMouseMove);
                    document.removeEventListener('mouseup', handleMouseUp);
                };

                this.elements.leftThumb.addEventListener('mousedown', (e) => handleMouseDown(this.elements.leftThumb, e));
                this.elements.rightThumb.addEventListener('mousedown', (e) => handleMouseDown(this.elements.rightThumb, e));
            }
        }

        // ========================================
        // Main Application
        // ========================================
 class WordListApp {
    constructor() {
        // Load configuration from external file
        if (typeof CONFIG === 'undefined') {
            console.error('CONFIG is not defined. Make sure config.js is loaded before this script.');
            alert('Configuration file (config.js) is missing. Please copy config.js.example to config.js and fill in your keys.');
            return;
        }
        
        const SUPABASE_URL = CONFIG.SUPABASE_URL;
        const SUPABASE_ANON_KEY = CONFIG.SUPABASE_ANON_KEY;
        const GEMINI_API_KEY = CONFIG.GEMINI_API_KEY;
        
        this.dataService = new DataService(SUPABASE_URL, SUPABASE_ANON_KEY);
        this.wordListComponent = new WordListComponent('wordContainer', {
            onWordClick: this.handleWordClick,
            minFontSize: 8,
            maxFontSize: 48,
            hoverFontSize: 72
        });
        this.titleListComponent = new TitleListComponent('rightPane', {
            onTitleClick: this.handleTitleClick,
            apiKey: GEMINI_API_KEY
        });
        this.rangeSlider = null;
        this.categorySelect = document.getElementById('categorySelect');
        this.allWords = [];
        this.currentWord = null;
        this.currentCategory = '';
        this.currentTitles = [];
        
        this._init();
    }

    _init = async () => {
        try {
            const categories = await this.dataService.fetchCategories();
            this._populateCategories(categories);
            
            this.wordListComponent.showLoading();
            this.allWords = await this.dataService.fetchWords();
            
            this.rangeSlider = new RangeSliderComponent({
                min: 1,
                max: 30,
                leftValue: 1,
                rightValue: 30,
                onChange: (left, right) => this.filterTitlesByDate(left, right)
            });
            
            this.wordListComponent.setWords(this.allWords);
            
            this.titleListComponent.showLoading();
            const allTitles = await this.dataService.fetchTitlesForWord('');
            this.currentTitles = allTitles;
            this.filterTitlesByDate(1, 30);
            
            this._attachEventHandlers();
            
        } catch (error) {
            console.error('Failed to initialize app:', error);
            this.wordListComponent.showError('Failed to load words. Please try again.');
            this.titleListComponent.showError('Failed to load articles. Please try again.');
        }
    }

    _populateCategories = (categories) => {
        categories.forEach(category => {
            const option = document.createElement('option');
            option.value = category;
            option.textContent = category;
            this.categorySelect.appendChild(option);
        });
    }

    _attachEventHandlers = () => {
        this.categorySelect.addEventListener('change', () => this.applyFilters());
        
        this._setupDivider();
    }

     filterTitlesByDate = (startDay, endDay) => {
        if (!this.currentTitles || this.currentTitles.length === 0) {
             this.titleListComponent.setTitles([]);
            return;
        }
        
        const currentYear = new Date().getFullYear();
        const startDate = new Date(currentYear, 4, startDay);
        const endDate = new Date(currentYear, 4, endDay, 23, 59, 59);
        
        const filteredTitles = this.currentTitles.filter(title => {
            const titleDate = new Date(title.publishDate);
            return titleDate >= startDate && titleDate <= endDate;
        });
        
        // This now correctly passes the currentEntity (or null) to the setTitles function
        this.titleListComponent.setTitles(filteredTitles, this.currentEntity);
    }

    applyFilters = async () => {
        const selectedCategory = this.categorySelect.value;
        
        if (selectedCategory !== this.currentCategory) {
            this.currentCategory = selectedCategory;
            this.wordListComponent.showLoading();
            
            try {
                this.allWords = await this.dataService.fetchWords({ 
                    category: selectedCategory 
                });
                this.wordListComponent.setWords(this.allWords);
                
            } catch (error) {
                console.error('Failed to load filtered words:', error);
                this.wordListComponent.showError('Failed to load words.');
            }
        }
    }

    handleWordClick = async (word, event) => {
        console.log('Word clicked:', word);
        this.currentWord = word;
        this.currentEntity = word.text; // Add this line

        
        try {
            this.titleListComponent.showLoading();
            const relatedTitles = await this.dataService.fetchTitlesForWord(word.text);
            this.currentTitles = relatedTitles;
            
            const leftValue = this.rangeSlider ? this.rangeSlider.config.leftValue : 1;
            const rightValue = this.rangeSlider ? this.rangeSlider.config.rightValue : 30;
            this.filterTitlesByDate(leftValue, rightValue);
            
        } catch (error) {
            console.error('Failed to load related titles:', error);
            this.titleListComponent.showError('Failed to load related articles.');
        }
    }

    handleTitleClick = async (title) => {
        console.log('Title clicked:', title);
        if(title.url && title.url !=='#') {
            window.open(title.url, '_blank');
        }
    }

    _setupDivider = () => {
        const divider = document.getElementById('divider');
        const leftPane = document.getElementById('leftPane');
        let isDragging = false;

        divider.addEventListener('mousedown', function(e) {
            isDragging = true;
            document.addEventListener('mousemove', handleDividerDrag);
            document.addEventListener('mouseup', stopDividerDrag);
        });

        function handleDividerDrag(e) {
            if (!isDragging) return;
            
            const containerWidth = document.body.clientWidth;
            const newLeftWidth = (e.clientX / containerWidth) * 100;
            
            const constrainedWidth = Math.max(20, Math.min(80, newLeftWidth));
            
            leftPane.style.width = constrainedWidth + '%';
        }

        function stopDividerDrag() {
            isDragging = false;
            document.removeEventListener('mousemove', handleDividerDrag);
            document.removeEventListener('mouseup', stopDividerDrag);
        }
    }
}
        const app = new WordListApp();
    </script>
</body>
</html>